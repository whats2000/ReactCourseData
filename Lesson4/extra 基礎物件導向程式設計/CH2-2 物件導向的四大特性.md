# 第二章：物件導向的四大特性(二)

### 2.3 抽象性（Abstraction）

考慮到現實中，我們經常會遇到一些複雜的問題，這些問題可能包含大量的細節和實現細節。在這種情況下，我們需要一種方法來隱藏這些細節，只暴露對外部使用者有用的功能。這就是抽象性的概念。
就直觀上來說，在一個類別找對應 method 的時候，會遇到冗長的程式碼，要是有個合約清單可以直接找到對應的 method 就好了，這就是抽象性的概念。

#### 2.3.1 概念

在程式設計中，抽象是一種隱藏複雜性、僅展示必要功能的方法。它可以通過使用抽象類別或接口來實現，這些類別和接口表示了一組廣泛的功能，而不提交具體的執行。

#### 2.3.2 目的
- 特色
  - 編譯後不會存在
- 管理複雜性：
    - 抽象的主要目的是簡化設計，使開發者可以不被背後的複雜實現所困擾，專注於高層次的策略。
- 增進可維護性：
    - 通過抽象，改變系統的內部實現而不影響外部使用者。
    - 這使得維護和擴展系統變得更容易。

#### 2.3.3 接口（Interfaces）

- 定義行為：
    - 接口僅定義行為，不提供實現。
    - 這意味著它們設定了一個可以被任何類別實現的合約，無論這些類別的功能如何。
- 提高靈活性：
    - 接口提高了程式的靈活性，允許多種不相關的類別實現同一個接口，支持多型性和插件式替換。

```typescript
interface Drawable {
  // 這說明該函數不會回傳任何東西，且不會有任何參數
  draw(): void;
}

class Circle implements Drawable {
  draw() {
    console.log("Drawing a circle");
  }
}

class Rectangle implements Drawable {
  draw() {
    console.log("Drawing a rectangle");
  }
}
```

#### 2.3.4 抽象類別（Abstract Classes）

- 特色
  - 一般命名都會以 `Abstract` 開頭，是為了讓開發者知道這是一個抽象類別。
  - **這些類別不能被實例化，只能被繼承。**
- 部分實現：
  - 抽象類別可以包含一些實現，但至少包含一個或多個未實現的方法。這是與接口的主要區別。
  - 這些未實現的方法必須由繼承抽象類別的子類實現。
- 建立框架：抽象類別常用來建立一個含有基本操作的框架，而讓具體的子類定義細節和特殊行為。

```typescript
abstract class AbstractShape {
  abstract area(): number;

  draw() {
    console.log("Drawing the shape with area: " + this.area());
  }
}

class Circle extends AbstractShape {
  constructor(private radius: number) {
    super();
  }

  area(): number {
    return Math.PI * this.radius * this.radius;
  }
}

const circle = new Circle(5);
circle.draw();  // Output: Drawing the shape with area: 78.53981633974483
```

## 2.4 多型性（Polymorphism）

考慮以下現實世界的例子來解釋多型性：

| 現實例子    | 描述                                                            |
|---------|---------------------------------------------------------------|
| 打印機     | 不同類型的打印機（雷射打印機、噴墨打印機）都有一個共同的“打印”操作，但每種打印機的打印細節（如打印速度和質量）可能不同。 |
| 交通工具    | 車輛如汽車、自行車和船，都可以執行“移動”操作，但每種交通工具的移動方式都有所不同。                    |
| 圖形界面的按鈕 | 在圖形用戶界面中，不同種類的按鈕（如圓形按鈕、方形按鈕）可能在被點擊時有不同的響應，儘管它們都執行“被點擊”的動作。    |

這些例子展示了多型性在實際應用中的重要性，允許我們以一致的方式使用不同的對象，同時又保留了它們各自的特有行為。

或許你會發現這個與 Union Type
的方法重載有點類似，這篇文章有詳細的解釋：[Union Types vs Interface Inheritance](https://dev.to/mahifoo/union-types-vs-polymorphism-writing-extensible-typescript-1mak)

### 2.4.1 概念

在物件導向程式設計中，多型性指的是同一個接口可以被不同類別的對象實現，使得不同類別的對象可以以相同的方式被處理。
具體實現可以通過介面（Interface）和繼承（Inheritance）來實現。

```typescript
interface Shape {
  area: number;

  draw(): void;
}

class Circle implements Shape {
  area: number;

  constructor(public radius: number) {
    this.area = Math.PI * Math.pow(this.radius, 2);
  }

  draw() {
    console.log("Drawing a circle");
  }
}

class Square implements Shape {
  area: number;

  constructor(public side: number) {
    this.area = Math.pow(this.side, 2);
  }

  draw() {
    console.log("Drawing a square");
  }
}

const circle = new Circle(5);
const square = new Square(5);

// 使用多型性，我們可以將不同類別的對象放在一個數組中
for (const shape of [circle, square] as Shape[]) {
  console.log(shape.area);
  // 不需要知道具體的類別，只需要知道它們實現了 Shape 介面，那我們就可以調用 draw 方法
  shape.draw();
}
```

在上面的例子中，`Shape` 是一個介面，它定義了一個 `area` 屬性和一個 `draw` 方法。

- `Circle` 和 `Square` 類別都實現了 `Shape` 介面，並提供了自己的 `area` 屬性和 `draw` 方法。
- 使用者不需要知道具體的類別，只需要知道它們實現了 `Shape` 介面，就可以調用 `draw` 方法。

### 2.4.2 目的

- 提高靈活性：
    - 通過多型性，軟件組件可以更靈活地處理不同類型的對象，而不需要知道對象的具體類別。
- 增加可擴展性：
    - 程式可以通過新增類別來擴展，而無需修改現有的程式碼，這是因為新的類別可以繼承使用相同的接口。

### 2.4.3 方法重載（Overloading）

- 定義：
    - 方法重載是多型性的一種表現形式，它允許在同一個類別中使用相同的方法名稱但是不同的參數列表。
- 作用：
    - 方法重載使得開發者可以為相同的操作提供多種參數配置，增加方法的靈活性。

```typescript
class Printer {
  print(text: string): void;
  print(text: string, copies: number): void;
  print(text: string, copies?: number): void {
    const times = copies || 1;
    for (let i = 0; i < times; i++) {
      console.log(text);
    }
  }
}

const printer = new Printer();
printer.print("Hello, World!");          // 印出一次
printer.print("Hello, World!", 3);       // 印出三次
```

### 2.4.4 方法重寫（Overriding）

- 定義：
    - 方法重寫是子類別改寫從父類別繼承來的一個方法的行為。
- 作用：
    - 方法重寫允許子類別提供特定於該類別的實現，它使得子類別可以根據需要改變繼承的行為。

```typescript
// 這個例子中的 BaseClass 不是抽象類別，故其實例化是合規的
class VehicleBase {
  drive(): void {
    console.log("Driving a vehicle unknown");
  }
}

class Car extends VehicleBase {
  drive(): void {
    console.log("Driving a car");
  }
}

class Bicycle extends VehicleBase {
  drive(): void {
    console.log("Riding a bicycle");
  }
}

class VehicleX extends VehicleBase {
}

const myVehicle = new Vehicle();
const myCar = new Car();
const myBicycle = new Bicycle();
const myVehicleX = new VehicleX();

myVehicle.drive();   // Output: Driving a vehicle
myCar.drive();       // Output: Driving a car
myBicycle.drive();   // Output: Riding a bicycle
myVehicleX.drive();  // Output: Driving a vehicle unknown
```

### 2.4.5 介面和繼承的比較

在物件導向程式設計中，使用介面（Interface）和繼承基礎類別（ Base Class / Super Class）是實現多型性的兩種主要方法。

#### 使用介面（Interface）

1. 介面定義契約：
    - 介面主要用來定義一組方法和屬性的契約，它不提供任何方法的實現。
    - 這允許實現該介面的任何類別自由地提供具體的實現。
2. 靈活性：
    - 介面允許一個類別實現多個介面，增加了程式設計的靈活性。
    - 這在某些語言中是非常有用的，尤其是在不支持多重繼承的語言（如Java和TypeScript）中。
3. 低耦合：
    - 使用介面可以減少系統各部分之間的耦合度。
    - 類別只需知道介面的定義，而不需要關心其他類別的具體實現，這有助於提高程式碼的模塊化和可重用性。

### 繼承基礎類別（Base Class）

很多時候 Base Class 也會是個抽象類別，這樣可以確保 Base Class 不會被實例化。但並不是所有的 Base Class 都是抽象類別。

1. 共享實現：
    - 基礎類別可以提供一些共通的實現，這樣所有繼承自該類別的子類別都可以使用這些實現。
    - 這避免了程式碼的重複，促進了程式碼的重用。
2. 建立類別階層：
    - 通過繼承可以建立一個清晰的類別階層結構。
    - 這使得維護和擴展變得更容易，因為新的功能可以通過添加新的子類或修改現有的子類來實現。
3. 直接使用父類屬性和方法：
    - 子類別可以直接訪問父類別中定義的保護（protected）或公共（public）屬性和方法，這可以簡化子類別的程式碼。

#### 選擇介面還是繼承

選擇使用介面還是繼承取決於具體的應用需求：

- **如果需要多個類別遵循同一套規範，但實現可能完全不同，則使用介面。**
- **如果多個類別之間有大量的共享程式碼，且從概念上它們屬於同一類型的對象，則使用繼承。**

通常，建議儘量使用介面來降低耦合度，提高系統的靈活性和可擴展性。繼承應當謹慎使用，因為不當的繼承可以導致類別階層變得難以管理和維護。

### 2.4.6 練習題

假設你正在開發一個繪圖應用，需要支持不同種類的圖形繪製，如圓形、正方形和三角形。每種形狀都應該可以計算面積和繪製自己。使用
TypeScript 的類別和介面來實現多型性，確保每個形狀都符合一個共同的接口，並且能夠在不知道具體形狀類型的情況下繪製和計算面積。

#### 要求

1. 定義一個 `Shape` 介面，它應該包含兩個方法：`calculateArea()` 和 `draw()`.
2. 創建三個類別：`Circle`, `Square`, 和 `Triangle`，讓這些類別實現 `Shape` 介面。
3. 在每個類別中實現 `calculateArea` 和 `draw` 方法。`draw` 方法應該輸出形狀名和一個簡單的描述。
4. 寫一個函數 `displayShapeInfo(shape: Shape)`，它接受一個 `Shape` 類型的對象，調用 `calculateArea()` 和 `draw()` 方法。
