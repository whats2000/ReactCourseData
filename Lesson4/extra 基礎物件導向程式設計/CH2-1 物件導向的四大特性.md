# 第二章：物件導向的四大特性(一)

## 2.1 封裝（Encapsulation）

在開發過程中，我們難免會需要處理一些敏感的數據，這些數據可能包含用戶的個人信息、金融資料等。
為了保護這些數據，並確保它們不被隨意訪問和修改，我們可以使用封裝來實現這一目的。

### 2.1.1 概念

在物件導向程式設計中，封裝是通過使用類別來實現的，類別中的數據（屬性）通常被隱藏於外界，只能被類別本身的方法訪問和修改。這些方法提供了一種安全的方式來修改它們的內部數據。

### 2.1.2 目的

封裝的主要目的是保護對象內部的數據，防止外部程式碼隨意更改對象內部的數據狀態。這有助於避免由於外部介入而造成的數據處理錯誤，並確保對象數據的安全性和一致性。

### 2.1.3 實例：存取修飾符在現實中的類比

回憶起上一章講解的存取修飾符，這實際上就是封裝的一種機制。

- public（公開）：這些屬性和方法對任何人都是可見的，就像一家餐廳的菜單一樣，任何顧客都可以看到並選擇它們。
- private（私有）：私有屬性和方法只能在類別內部使用，外部是無法訪問的。這就像是餐廳廚房中的秘密食譜，顧客無法看到，只有廚師能夠使用這些食譜來準備菜餚。
- protected（受保護的）：受保護的屬性和方法只對類別及其子類別可見。這可以理解為家族企業的內部操作手冊，只有家族成員和繼承者可以理解和使用這些指南。

### 2.1.4 例子：銀行帳戶類別

考慮一個銀行帳戶的例子，其中包含有關帳戶餘額的敏感信息。帳戶的餘額應該被設定為私有（private），這樣它就不能被直接修改，而只能通過公開（public）的存款和取款方法來間接修改。

```typescript
class BankAccount {
  private balance: number;

  constructor(initialBalance: number) {
    this.balance = initialBalance;
  }

  //  公開的存款方法
  public deposit(amount: number): void {
    if (amount > 0) {
      this.balance += amount;
      console.log(`存款成功: ${amount}元`);
    }
  }

  // 公開的取款方法
  public withdraw(amount: number): void {
    if (amount <= this.balance) {
      this.balance -= amount;
      console.log(`取款成功: ${amount}元`);
    } else {
      console.log("餘額不足");
    }
  }

  // 公開的獲取餘額方法
  public getBalance(): number {
    return this.balance;
  }
}

const myAccount = new BankAccount(1000);
myAccount.deposit(500);
myAccount.withdraw(800);
console.log(`帳戶餘額: ${myAccount.getBalance()}元`);  // 輸出當前餘額
```

在這個例子中，`balance` 屬性被設為 `private`，這意味著它不能被外部直接訪問，只能通過 `deposit` 和 `withdraw`
方法來修改，這些方法檢查條件以確保操作的正確性。這是封裝的一個典型應用，保護了數據的完整性同時提供了用戶操作的接口。

### 2.1.5 練習題：

1. 練習設計一個類別：
    - 創建一個名為 `Car` 的類別，代表一輛汽車。
    - 為 `Car` 類別添加私有屬性 `speed`（當前速度）和 `fuel`（剩餘燃料百分比）。
    - 添加公開方法 `accelerate()` 和 `brake()`，分別用於加速和減速。當加速時，速度增加，燃料消耗增多；當減速時，速度減少。
    - 為 `Car` 類別添加一個公開方法 `addFuel(percentage: number)`，用於增加燃料。

2. 實現安全的數據修改：
    - 確保 `speed` 和 `fuel` 的修改只能通過類別的方法來進行。不允許外部直接修改這些屬性。
    - 在 `accelerate()` 和 `brake()` 方法中加入檢查，確保速度不會低於0或高於一個最大值。同樣，確保燃料不會低於0或超過100%。

3. 撰寫測試程式碼：
    - 創建一個 `Car` 對象，初始速度為0，燃料為50%。
    - 調用加速方法幾次，然後調用減速方法，並觀察速度和燃料的變化。
    - 嘗試添加燃料並檢查燃料是否有正確增加。

## 2.2 繼承（Inheritance）

考慮現實中有很多類別之間的相似性，比如汽車和卡車都是車輛，都有一些共同的特性，比如顏色(color)、模型(model)、燃料(fuel)
等。但是，兩者也有些許不同。

- 比如卡車有附載重量(load capacity)這個特性，而汽車沒有。
- 汽車可能有一些特有的特性，比如內飾材料(interior material)等。

如下方表格所示：

| 類別 | 共同特性     | 特有特性 |
|----|----------|------|
| 車輛 | 顏色、模型、燃料 |      |
| 汽車 |          | 內飾材料 |
| 卡車 |          | 附載重量 |

如果分別為汽車和卡車創建兩個獨立的類別，則需要重複編寫一些程式碼。這會很冗長，尤其是比方當共有特性發生變化時，需要對所有類別進行修改。此時，繼承就可以派上用場。

### 2.2.1 概念

繼承是物件導向程式設計的一個核心概念，它允許一個類別（稱為子類別）繼承另一個類別（稱為父類別）的特性，包括屬性和方法。當父類別的特性被修改時，子類別也會一同受到影響。

### 2.2.2 目的

繼承的主要優點是促進了程式碼的重用。通過繼承，子類別可以重用父類別的程式碼而無需重寫，同時還可以添加或修改現有的行為。這使得程式碼更加模組化，易於管理和擴展。

### 2.2.3 實例：繼承的應用

在 TypeScript 物件導向程式設計中，`extends` 和 `super`
是實現繼承的兩個關鍵語法元素，主要用於類別間的功能擴展和程式碼重用。下面我將詳細解釋這兩個關鍵字的用途和作用，以及繼承對封裝和存取修飾符的影響。

#### 關於 `extends` 定義與用途

- `extends` 是 TypeScript（及其他許多物件導向語言如 Java, C#）中用來實現類別繼承的關鍵字。
- 當一個類別使用 `extends` 繼承另一個類別時，它將繼承父類別的所有屬性和方法。
- 這允許開發者建立一個新類別在現有類別的基礎上，增加或修改某些功能。

```typescript
class Animal {
  breathe() {
    console.log("Breathing");
  }
}

class Dog extends Animal {
  bark() {
    console.log("Barking");
  }
}

const myDog = new Dog();
myDog.breathe(); // 繼承自 Animal
myDog.bark();    // 定義在 Dog
```

在這個例子中，`Dog` 類別透過 `extends` 繼承了 `Animal` 類別，因此 `Dog` 的實例可以訪問 `breathe` 方法。

#### 關於 `super` 定義與用途

`super` 是一個函數，也是一個關鍵字，用於調用父類別的建構子、方法。

- 它在子類別的建構子中特別有用，用於初始化從父類別繼承的屬性。
- 你可以想像實例化，進行初始化會同時調用父類別的建構子，確保父類別的屬性被正確初始化。

#### 例子

```typescript
class Animal {
  constructor(public name: string) {
  }
}

class Dog extends Animal {
  constructor(name: string, public owner: string) {
    super(name); // 調用 Animal 的建構子
  }
}

const myDog = new Dog("Buddy", "John");
console.log(myDog.name); // Buddy
```

這裡，`Dog` 的建構子使用 `super` 調用了 `Animal` 的建構子，確保 `name` 屬性被正確初始化。

### 2.2.4 繼承與存取修飾符

#### 封裝的變更

繼承可能影響類別的封裝，尤其是與存取修飾符（如 `private`, `protected`, `public`）相關。存取修飾符定義了屬性和方法的可訪問性。

- `public`：可在任何地方訪問，無論是類別內部還是外部。
- `private`：只能在類別內部訪問，不可在子類別中訪問。
- `protected`：可以在類別內部和子類別中訪問，但不能在類別外部直接訪問。

#### 例子

```typescript
class Animal {
   public name: string;
   private secret = "I'm a secret";
   protected familySecret = "Family secret";

   constructor(name: string) {
      this.name = name;
   }
}

class Dog extends Animal {
   constructor(name: string) {
      super(name);
   }

   shareSecret() {
      // console.log(this.secret);    // 錯誤：不能訪問 'private' 屬性
      console.log(this.familySecret); // 正確：可以訪問 'protected' 屬性
   }
}

const myDog = new Dog("Buddy");
console.log(myDog.name); // Buddy
myDog.shareSecret(); // 輸出：Family secret
// myDog.familySecret; // 錯誤：不能在類別外部訪問 'protected' 屬性
```

這個例子展示了 private 和 protected 屬性在繼承中的行為。private 屬性即便在子類別中也無法訪問，而 protected 屬性則可以在子類別中訪問，但不能在類別外部直接訪問。

### 2.2.5 練習題：

1. 背景
   - 假設你正在開發一個遊戲應用，需要模擬不同類型的遊戲角色。
   - 有一個基礎的角色類別 Character，其中包括了所有角色共有的特性和功能。
   - 你需要擴展這個基礎類別來創建具體的角色類別，如 Warrior 和 Mage。

2. 任務
   - 定義一個基礎類別 Character，具有以下屬性和方法：
   - 一個 protected 屬性 health 代表角色的生命值。
   - 一個 public 方法 displayHealth() 用於顯示角色的當前生命值。

3. 從 Character 類別繼承兩個子類別：Warrior 和 Mage。
   - 其中 Mage 類別繼承自 Character，並添加一個特有的屬性 mana 代表法力值。
   - Warrior 類別也繼承自 Character，並添加一個特有的屬性 strength 代表力量值。
   - 每個子類別應該有一個特定的 public 方法來模擬角色的特殊行為。
     - Warrior 有 attackWithSword() 會對另一個角色 health 造成傷害。
     - Mage 有 castSpell() 會對另一個角色 health 造成傷害。並消耗 mana。

4. 創建這些類別的實例，並在一個主程式中展示它們的行為。
